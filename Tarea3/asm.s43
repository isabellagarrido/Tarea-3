#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    ISR_TIMER_A0            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    ISR_PORT1               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM

        ORG     01C00h                  
 
; pushCount dw    0                       ;Counter for how many times button S1 is pressed


;------------------------------------------------------------------------------
;Letters and Symbols
;            A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z   NONE    -     >     ?
;            0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25   26    27    28    29   
CharH   db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x00, 0x78, 0x0E, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0x03, 0x00, 0xC5
 
; CharH index:     30    31    32    33    34    35    36    37    38    39
               ;    0     1     2     3     4     5     6     7     8     9
digitH          DB 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7

CharL   db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x22, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x00, 0x88, 0x10
digitL          DB 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00

;------------------------------------------------------------------------------
; Display Strings
; Array of CharH and CharL INDICES

; Players
jann            DB      9, 0, 13, 13, 26, 26
isabel          DB      8, 18, 0, 1, 4, 11
vandie          DB      21, 0, 13, 3, 8, 4
ricard          DB      17, 8, 2, 0, 17, 3
dracir          DB      3, 17, 0, 2, 8, 17
uimerf          DB      20, 8, 12, 4, 17, 5
oravan          DB      16, 17, 0, 21, 0, 13


; Misc. Titles
kasino          DB      10, 0, 18, 8, 13, 14
record          DB      17, 4, 2, 14, 17, 3
test            DB      19, 4, 18, 19, 26, 26    
pro             DB      15, 17, 14, 26, 26, 26
player          DB      15, 11, 0, 24, 4, 17
mode            DB      12, 14, 3, 4, 26, 26    ; NOTE: To make Y/N appear after mode
                                                ; edit @mode+5 (the final position)

;                       T   P
modeValues      DB      19, 15

s2clr           DB      18, 32, 2, 11, 17, 26
perdio          DB      15, 4, 17, 3, 8, 14
gano            DB      6, 0, 13, 14, 26, 26

; Array of string addresses
;                       0       2       4        6     8        10      11     12
recordPage      DW      record, ricard, number, test, number                            ; Indexed by R8 * 2
namePage        DW      player, ricard, jann, isabel, vandie, dracir, uimerf, oravan    ; Indexed by R5 * 2
resultPage      DW      perdio, gano                                                    ; Indexed by R9 * 2



;                       0       2           4         6     10      12          14
pages           DW      kasino, recordPage, namePage, mode, number, resultPage, s2clr   ; Indexed by R4 * 2

; LCD Offsets
LCD_offsets db 9, 5, 3, 18, 14, 7

; Input Buttons
S1              db      00000100B 
S2              db      00000010B

; Timer Mode Counts (seconds)
;                       1/8   1/4   1/2  1   2   5
countsNeeded    DB      1,    2,    4,   8, 16, 40

; Game timer modes      2  2  1  1/2  1/4  1/8
proTimerModes   DB      4, 4, 3, 2,   1,   0

; Game number (0 = 30 ... 9 = 39)
number          DB      30, 30, 30, 30, 30, 30


;------------------------------------------------------------------------------
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

        ; === Port Settings ===

        ; Port 1 Setup
        bis.b   #011111001B, &P1DIR     ; Port 1.1 & Port 1.2 for button input, all other as output
        bis.b   #00000001b, &P1OUT      ; Turn on red LED

	bis.b   #00000110B, &P1OUT	; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1

        bis.b   #00000110B, &P1IES     ; Int generated on high to low transition
        bis.b   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2


        ; Port 9 Setup
        bis.b 	#10000000b, &P9OUT       ; Turn on green LED
	bis.b   #011111111B, &P9DIR     ; All Port 9 pins as output


        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        ; === LCD Settings ===

        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
          
        ; Initialize LCD 
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0            ; turn the LCD on


        ; === Timer Settings ===

        BIC     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.125 seg
        ; cycles = 15625.  With period = 0.125 LED turn on every 1 second

        mov     #15625, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.



main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer  

        CALL    #reset                  ; Reset values
                         
        nop				; required before enabling interrupts

        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers

        nop                             ; Required after enabling interrupts
          
          
        ; At this point, the MSP430 is now in low power mode
        ; and can only handle interrupts.
        ; Because of this, all code should be handled using interrupts
        


;------------------------------------------------------------------------------
SUB_updateCurrentPage:
        
        PUSH.w  R10                     ; Preserve the original value of R10
                                        ; R10 will contain the page that we want to render

        PUSH.w  R11                     ; Preserve the original value of R11
                                        ; R11 will contain the amount we need to shift R10 by


        PUSH.w  R4                      ; Preserve the original value of R4
                                        ; R4 will be multiplied by 2 to index "pages"

        RLA     R4                      ; Multiply R4 by 2

        MOV.w   pages(R4), R10          ; At this point, R10 is either an address pointing to a string
                                        ; or an address pointing to array of string pointers

        POP.w   R4                      ; Restore R4's value

        CMP     #1, R4                  ; Record (indexes R10 using R8)
        JEQ     shiftR10ByR8
        
        CMP     #2, R4                  ; Names (indexes R10 using R5)
        JEQ     shiftR10ByR5
        
        CMP     #5, R4                  ; Result (indexes R10 using R9)
        JEQ     shiftR10ByR9
        
        JMP     endDisplay              ; It's an address that points to a string!
        
shiftR10ByR8:
        MOV     R8, R11
        JMP     shiftLoop
        
shiftR10ByR5:
        MOV     R5, R11
        JMP     shiftLoop
        
shiftR10ByR9:
        MOV     R9, R11

shiftLoop:
        CMP     #0, R11
        JEQ     endLoop
        
        
        INCD    R10                     ; Increase R10 by 2 (since addresses are words)
                                        ; R10 now points to the next address in the array
        DEC     R11
        JMP     shiftLoop
        
endLoop:
        MOV     @R10, R10               ; Turn R10 from an address that points to an address that points to a string
                                        ; to an address that points to a string

endDisplay:
      
        CALL    #SUB_displayStringOnLCD
        POP.w   R11                    ; Restore R11's value
        POP.w   R10                    ; Restore R10's value
        RET
        
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Author: Jann C. Garcia
; Date: November 12, 2022
; Description:
; * Receives a starting address from R10, and displays the next 6 characters
; * on the LCD. 

; Pre-Conditions: 
; * R10 must denote a location of memory where a string commences
; * The string MUST be of bytes. Words will not work

; Post-Conditions: None
; Side Effects: None

SUB_displayStringOnLCD:
        ; Setup
        PUSH.w R10                      ; R10: Starting address in RAM of string
                                        ; Each position is an index for CharH/CharL
                                        ; Move 6 places and display each digit

        PUSH.w R11                      ; R11: Goes from 0-6
                                        ; Due to LCD addresses NOT being in order,
                                        ; we need to use LCD_offsets, which contains
                                        ; the correct offset for each segment of the LCD
                                        ; For example: segment 0 is 0xA29 (A20 + 9 offset)
                                        ; but segment 1 is 0xA25 (A20 + 5 offset)

        PUSH.w R12                      ; R12: The index of CharH/CharL
        
        MOV     #0, R11
        
displayLoop:

        MOV.b   @R10+, R12              ; Store the value AT (@) R10 into R12
                                        ; The + increments the value IN R10
                                        ; so that R10 will point to the next byte
                                        ; in RAM

        PUSH.W  R11                     ; Temporarily store R11's index
        
        MOV.b   LCD_offsets(R11), R11   ; Grab the current offset for R11
        MOV.b   CharH(R12), 0x0A20(R11)   ; High Byte
        MOV.b   CharL(R12), 0x0A20+1(R11) ; Low Byte
        
        POP.w   R11                     ; Restore R11's index
        INC.b   R11                     ; and increase it by 1
        
        CMP     #6, R11                 ; End if R11 has reached 6
        JL      displayLoop
        
        ; Restore original values to prevent side effects
        POP.w   R12
        POP.w   R11
        POP.w   R10
        
        RET
        
        
;------------------------------------------------------------------------------
SUB_S1Action:
        ; TODO: Set timer mode for state transitions
        CMP     #0, R4
        JEQ     moveToIntroLoop
        
        CMP     #2, R4
        JEQ     moveToNextPlayer
        
        
        CMP     #3, R4
        JEQ     toggleMode
        
        CMP     #4, R4
        JEQ     handleGameState
        
        CMP     #6, R4
        JEQ     resetGame
        
        ;DONE
        
        JMP     end_S1Action
        
;------------------------------------------------------------------------------

moveToIntroLoop:
        MOV     #1, R4                  ; Move to Intro State

        MOV     #4, R6                  ; Set timer to 2 second mode
        CALL    #SUB_enableTimer        ; Reset and enable timer


        JMP     end_S1Action
;------------------------------------------------------------------------------        
moveToNextPlayer:
        INC     R5                      ; Increase name index
        CMP     #8, R5
        JNE     end_S1Action
        
        MOV     #1, R5                  ; Reset Name Index
        JMP     end_S1Action
        
        
        
;------------------------------------------------------------------------------
       
toggleMode:
        XOR     #1, R11
        PUSH.w  R10
        MOV.w   #mode, R10
        
        MOV     modeValues(R11), 5(R10)  ; Change mode to T or P
        POP.w   R10
        JMP     end_S1Action
        
;------------------------------------------------------------------------------        
handleGameState:
        PUSH.w  R11
        MOV.w   #number, R11
        CMP     number(R10), 0(R11)     ; Compare current number to first number
        POP.w   R11
        JNE     failGame                ; We chose a different number! D:
        
        INC     R10                     ; Increase index to the next number
        
        CMP     #6, R10                 
        JEQ     winGame                 ; We reached the end! :)

        CMP     #1, R11                 ; Check if we are playing pro mode
        JEQ     updateTimerValueForPro
        
        MOV     #4, R6                  ; Set timer to 2 second mode
        JMP     continueGame

updateTimerValueForPro:
        MOV     proTimerModes(R10), R6  ; Set timer to mode @ index R10


continueGame:        
        CALL    #SUB_resetTimer         ; Reset the timer
        JMP     end_S1Action            ; We haven't finished yet!
        
failGame:
        MOV     #0, R9                  ; We lost :(
        JMP     moveToResultState
        
winGame:
        MOV     #1, R9                  ; We won!
        
moveToResultState:
        MOV     #5, R4                  ; Move to result state
        MOV     #5, R6                  ;change freq to 5s
        CALL    #SUB_enableTimer       ; Reset and disable the timer
        JMP     end_S1Action
        
;------------------------------------------------------------------------------
    
resetGame:
        CALL    #reset
        ; TODO: Store High score in FRAM?
        

end_S1Action:        
        RET
      
;------------------------------------------------------------------------------

SUB_S2Action:
        ; TODO: implement
        RET
        
        
;-------------------------------------TIMER ACTIONS-----------------------------------------

SUB_timerAction:

        CMP     #1, R4                          ;checks if page is 1 
        JEQ     name_Records
        
        CMP     #4, R4
        JEQ     game_State
        
        CMP     #5, R4
        JEQ     result_State 
        
        
end_TimerAction:
        CALL      #SUB_updateCurrentPage       ; Update the page AFTER we performed our action
        XOR.b     #BIT7, &P9OUT                 ; Toggle the Green LED
        RET
        
name_Records:
        INC     R8
        CMP     #5, R8
        JEQ     reset_Eight
        JMP     end_TimerAction
        
reset_Eight:
        MOV     #0, R8
        JMP     end_TimerAction
        
game_State:
        INC     number(R10)
        CMP     #10,  number(R10)
        JGE     failState
        JMP     end_TimerAction

failState:
        MOV     #0, R9
        MOV     #5, R6
        MOV     #5, R4
        JMP     end_TimerAction

result_State:
        MOV     #6, R4
        CALL    #SUB_disableTimer
        JMP     end_TimerAction
       
        
;------------------------------------RESET IS HERE------------------------------------------
reset:
        MOV     #0, R4                  ; R4 = Current State
                                        ; * 0 = Title State
                                        ; * 1 = Record Loop
                                        ; * 2 = Player Selection
                                        ; * 3 = Mode Selection
                                        ; * 4 = Game State (pro/test defines speed)
                                        ; * 5 = Game result state
                                        ; * 6 = S2CLR State

        MOV     #0, R5                  ; R5 = Name Index
                                        ; * 0 = "Player"
                                        ; * 1 = "Ricard"  <-- loop here!
                                        ; * ...
                                        ; * 7 = "Oravan"

        MOV     #0, R6                  ; R6 = Timer Mode
                                        ; * 0 = 1/8th
                                        ; * 1 = 1/4th
                                        ; * 2 = 1/2
                                        ; * 3 = 1
                                        ; * 4 = 2
                                        ; * 5 = 5

        MOV     #0, R7                  ; R7 = 1/8th of a second counter (counter)[it counts]

        MOV     #0, R8                  ; R8 = Record Page Index
                                        ; * 0 = "Record"        <-- loop here!
                                        ; * 1 = Record Holder Name
                                        ; * 2 = Record Holder Score
                                        ; * 3 = "Test"
                                        ; * 4 = Test Record Score

        MOV     #0, R9                  ; R9 = Game Result
                                        ; * 0 = Lose :(
                                        ; * 1 = Win  :)

        MOV     #0, R10                 ; R10 = Current Game Number
                                        ; * 0 = First Number
                                        ; * ...
                                        ; * 5 = Last Number
  
        MOV     #0, R11                 ; R11 = Game Mode
                                        ; * 0 = Test
                                        ; * 1 = Pro

        CALL    #SUB_disableTimer       ; Reset and Disable the timer

        RET

;------------------------------------------------------------------------------
SUB_resetTimer:
        MOV     #0, R7                  ; Reset Counter
        RET

SUB_disableTimer:
        CALL    #SUB_resetTimer         ; Reset Timer
        BIC     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer
        RET
        
SUB_enableTimer:
        CALL    #SUB_resetTimer         ; Reset Timer
        BIS     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer
        RET
        

;------------------------------------------------------------------------------

; Author: Jann C. Garcia
; Date: October 31, 2022
; Description: Delays the program 9for debouncing)
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None


delay:  ; Used to delay the program
        ; giving the MSP time to handle
        ; button pressed (debouncing)

        PUSH.w    R7                            ; Preserve Original Value                       
        CALL    #delayStart
        POP.w     R7                              ; Restore Original Value
        RET
        
delayStart:
        MOV     #0xFFFF,R7                      ; Set R7 to an abnormally high value       


next:   ; Decrease R7 all the way to 0
        DEC     R7                       
        JNZ     next
        RET
;------------------------------------------------------------------------------
ISR_TIMER_A0:

        INC     R7                      ; Increase the counter
        PUSH.w    R12

        MOV.b   countsNeeded(R6), R12
        CMP.b   R12, R7   
        POP.w     R12
        JNE     end_timer_interrupt     ; Ignore the current interrupt

        
        ; We reached the needed cycles
        CALL    #SUB_timerAction        ; name pending
        MOV     #0, R7                  ; Reset R7
        
      
end_timer_interrupt: 
        RETI

;------------------------------------------------------------------------------

;------------------------------------------------------------------------------

 ;Interrupt Service Routine (ISR) that is executed when button S1
 ;is pressed.

;------------------------------------------------------------------------------

; Author(s): Jann C. Garcia
; Date: November 12, 2022
; Description: TODO
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None

ISR_PORT1:   

        NOP                            
	bic.b   #00000110b, &P1IFG	  ;Reset interrupt flag
        NOP  

        PUSH.w  R10                     ; Store original value of R10
        MOV.b   &P1IN, R10               ; Get button state from P1
        AND.b   #00000110B, R10         ; Apply bit mask to value

        CMP.b    S1, R10                 ; Check if S1 was pressed (sets to 0 when pressed)
        JEQ     callButton1Action
        
        
        CMP.b    S2, R10                  ; Check if S2 was pressed 
        JEQ     callButton2Action
        JMP     end_ISR_Port1
        
callButton1Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R10               ; Get button state from P1 
        AND.b   #00000110B, R10          ; Apply bit mask to value

        CMP.b   S1, R10
        JEQ     end_ISR_Port1

        CALL    #SUB_S1Action
        JMP     end_ISR_Port1           ; Skip over button2 action
        
callButton2Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R10               ; Get button state from P1 
        AND.b   #00000110B, R10          ; Apply bit mask to value

        CMP.b   S2, R10
        JEQ     end_ISR_Port1
        
        CALL    #SUB_S2Action


end_ISR_Port1
        POP.w   R10                     ; Restore original value of R10
        CALL    #SUB_updateCurrentPage       ; Update the page AFTER we performed our action
	reti
;------------------------------------------------------------------------------
   
endProgram:                             ; Theoretically should never run
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)    
        END