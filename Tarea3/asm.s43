#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    ISR_TIMER_A0            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    ISR_PORT1               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM

        ORG     01C00h                  
 
; pushCount dw    0                       ;Counter for how many times button S1 is pressed


;------------------------------------------------------------------------------
;Letters and Symbols
;            A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z   NONE    -     >     ?
;            0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25   26    27    28    29   
CharH   db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x00, 0x78, 0x0E, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0x03, 0x00, 0xC5
 
; CharH index:     30    31    32    33    34    35    36    37    38    39
               ;    0     1     2     3     4     5     6     7     8     9
digitH          DB 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7

CharL   db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x22, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x00, 0x88, 0x10
digitL          DB 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00

;------------------------------------------------------------------------------
; Display Strings
; Array of CharH and CharL INDICES

; Players
jann            DB      9, 0, 13, 13, 26, 26
isabel          DB      8, 18, 0, 1, 4, 11
vandie          DB      21, 0, 13, 3, 8, 4
ricard          DB      17, 8, 2, 0, 17, 3
dracir          DB      3, 17, 0, 2, 8, 17
uimerf          DB      20, 8, 12, 4, 17, 5
oravan          DB      16, 17, 0, 21, 0, 13


; Misc. Titles
kasino          DB      10, 0, 18, 8, 13, 14
record          DB      17, 4, 2, 14, 17, 3
test            DB      19, 4, 18, 19, 26, 26    
pro             DB      15, 17, 14, 26, 26, 26
player          DB      15, 11, 0, 24, 4, 17
mode            DB      12, 14, 3, 4, 26, 26    ; NOTE: To make Y/N appear after mode
                                                ; edit @mode+5 (the final position)

s2clr           DB      18, 32, 2, 11, 17, 26
perdio          DB      15, 4, 17, 3, 8, 14
gano            DB      6, 0, 13, 14, 26, 26

; Array of string addresses
;                       0       2       4        6     8        10      11     12
recordPage      DW      record, ricard, number, test, number                            ; Indexed by R8 * 2
namePage        DW      player, ricard, jann, isabel, vandie, dracir, uimerf, oravan    ; Indexed by R5 * 2
resultPage      DW      perdio, gano                                                    ; Indexed by R9 * 2



;                       0       2           4         6     8       10           12
pages           DW      kasino, recordPage, namePage, mode, number, resultPage, s2clr   ; Indexed by R4 (R4 must be even)

; LCD Offsets
LCD_offsets db 9, 5, 3, 18, 14, 7

; Input Buttons
S1              db      00000100B 
S2              db      00000010B

; Timer Mode Counts (seconds)
;                       1/8   1/4   1/2  1   2   5
countsNeeded    DB      1,    2,    4,   8, 16, 40

; Game number (0 = 30 ... 9 = 39)
number          DB      30, 30, 30, 30, 30, 30


;------------------------------------------------------------------------------
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

        ; === Port Settings ===

        ; Port 1 Setup
        bis.b   #011111001B, &P1DIR     ; Port 1.1 & Port 1.2 for button input, all other as output
        bis.b   #00000001b, &P1OUT      ; Turn on red LED

	bis.b   #00000110B, &P1OUT	; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1

        bis.b   #00000110B, &P1IES     ; Int generated on high to low transition
        bis.b   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2


        ; Port 9 Setup
        bis.b 	#10000000b, P9OUT       ; Turn on green LED
	bis.b   #011111111B, &P9DIR     ; All Port 9 pins as output


        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        ; === LCD Settings ===

        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
          
        ; Initialize LCD 
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0            ; turn the LCD on


        ; === Timer Settings ===

        BIC     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.125 seg
        ; cycles = 15625.  With period = 0.125 LED turn on every 1 second

        mov     #15625, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.



main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer  

        ; TODO: Maybe we can handle displays here instead of in interrupts?
        ; Interrupts should halt program flow: not control it.
        ; Investigate :)
        CALL    #reset
         
        ; Display title screen
        
mainLoop:
        CALL    #SUB_displayCurrentPage
        
        nop				; required befor enabling interrupts

        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts

        JMP     mainLoop
        

endProgram:
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)


;------------------------------------------------------------------------------
SUB_displayCurrentPage:
        
        PUSH.w  R10                     ; Preserve the original value of R10
                                        ; R10 will contain the page that we want to render

        PUSH.w  R11                     ; Preserve the original value of R11
                                        ; R11 will contain the amount we need to shift R10 by


        PUSH.w  R4                      ; Preserve the original value of R4
                                        ; R4 will be multiplied by 2 to index "pages"

        RLA     R4                      ; Multiply R4 by 2

        MOV.w   pages(R4), R10          ; At this point, R10 is either an address pointing to a string
                                        ; or an address pointing to array of string pointers

        POP.w   R4                      ; Restore R4's value

        CMP     #1, R4                  ; Record (indexes R10 using R8)
        JEQ     shiftR10ByR8
        
        CMP     #2, R4                  ; Names (indexes R10 using R5)
        JEQ     shiftR10ByR5
        
        CMP     #5, R4                  ; Result (indexes R10 using R9)
        JEQ     shiftR10ByR9
        
        JMP     endDisplay              ; It's an address that points to a string!
        
shiftR10ByR8:
        MOV     R8, R11
        JMP     shiftLoop
        
shiftR10ByR5:
        MOV     R5, R11
        JMP     shiftLoop
        
shiftR10ByR9:
        MOV     R9, R11

shiftLoop:
        CMP     #0, R11
        JEQ     endLoop
        
        
        INCD    R10                     ; Increase R10 by 2 (since addresses are words)
                                        ; R10 now points to the next address in the array
        DEC     R11
        JMP     shiftLoop
        
endLoop:
        MOV     @R10, R10               ; Turn R10 from an address that points to an address that points to a string
                                        ; to an address that points to a string

endDisplay:
      
        CALL    #SUB_displayStringOnLCD
        POP.w   R11                    ; Restore R11's value
        POP.w   R10                    ; Restore R10's value
        RET
        
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Author: Jann C. Garcia
; Date: November 12, 2022
; Description:
; * Receives a starting address from R10, and displays the next 6 characters
; * on the LCD. 

; Pre-Conditions: 
; * R10 must denote a location of memory where a string commences
; * The string MUST be of bytes. Words will not work

; Post-Conditions: None
; Side Effects: None

SUB_displayStringOnLCD:
        ; Setup
        PUSH.w R10                      ; R10: Starting address in RAM of string
                                        ; Each position is an index for CharH/CharL
                                        ; Move 6 places and display each digit

        PUSH.w R11                      ; R11: Goes from 0-6
                                        ; Due to LCD addresses NOT being in order,
                                        ; we need to use LCD_offsets, which contains
                                        ; the correct offset for each segment of the LCD
                                        ; For example: segment 0 is 0xA29 (A20 + 9 offset)
                                        ; but segment 1 is 0xA25 (A20 + 5 offset)

        PUSH.w R12                      ; R12: The index of CharH/CharL
        
        MOV     #0, R11
        
displayLoop:

        MOV.b   @R10+, R12              ; Store the value AT (@) R10 into R12
                                        ; The + increments the value IN R10
                                        ; so that R10 will point to the next byte
                                        ; in RAM

        PUSH.W  R11                     ; Temporarily store R11's index
        
        MOV.b   LCD_offsets(R11), R11   ; Grab the current offset for R11
        MOV.b   CharH(R12), 0x0A20(R11)   ; High Byte
        MOV.b   CharL(R12), 0x0A20+1(R11) ; Low Byte
        
        POP.w   R11                     ; Restore R11's index
        INC.b   R11                     ; and increase it by 1
        
        CMP     #6, R11                 ; End if R11 has reached 6
        JL      displayLoop
        
        ; Restore original values to prevent side effects
        POP.w   R12
        POP.w   R11
        POP.w   R10
        
        RET
        
        
;------------------------------------------------------------------------------
SUB_S1Action:
        ; TODO: implement
        CMP     #0, R4
        JEQ     moveToIntroLoop
        
        ; TODO: Add actions between these lines of code
        
        JMP     end_S1Action
        

moveToIntroLoop:
        MOV     #1, R4                  ; Move to Intro State


        JMP     end_S1Action
        

end_S1Action:        
        RET
      
;------------------------------------------------------------------------------

SUB_S2Action:
        ; TODO: implement
        RET
        
        
;------------------------------------------------------------------------------

SUB_timerAction:
        ; TODO: implement
        RET

;------------------------------------------------------------------------------
reset:
        MOV     #0, R4                  ; R4 = Current State
                                        ; * 0 = Title State
                                        ; * 1 = Record Loop
                                        ; * 2 = Player Selection
                                        ; * 3 = Mode Selection
                                        ; * 4 = Game State (pro/test defines speed)
                                        ; * 5 = Game result state
                                        ; * 6 = S2CLR State

        MOV     #0, R5                  ; R5 = Name Index
                                        ; * 0 = "Player"
                                        ; * 1 = "Ricard"  <-- loop here!
                                        ; * ...
                                        ; * 7 = "Oravan"

        MOV     #0, R6                  ; R6 = Timer Mode
                                        ; * 0 = 1/8th
                                        ; * 1 = 1/4th
                                        ; * 2 = 1/2
                                        ; * 3 = 1
                                        ; * 4 = 2
                                        ; * 5 = 5

        MOV     #0, R7                  ; R7 = 1/8th of a second counter (counter)[it counts]

        MOV     #0, R8                  ; R8 = Record Page Index
                                        ; * 0 = "Record"        <-- loop here!
                                        ; * 1 = Record Holder Name
                                        ; * 2 = Record Holder Score
                                        ; * 3 = "Test"
                                        ; * 4 = Test Record Score

        MOV     #0, R9                  ; R9 = Game Result
                                        ; * 0 = Lose :(
                                        ; * 1 = Win  :)

        RET
        

;------------------------------------------------------------------------------

; Author: Jann C. Garcia
; Date: October 31, 2022
; Description: Delays the program 9for debouncing)
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None


delay:  ; Used to delay the program
        ; giving the MSP time to handle
        ; button pressed (debouncing)

        PUSH.w    R7                            ; Preserve Original Value                       
        CALL    #delayStart
        POP.w     R7                              ; Restore Original Value
        RET
        
delayStart:
        MOV     #0xFFFF,R7                      ; Set R7 to an abnormally high value       


next:   ; Decrease R7 all the way to 0
        DEC     R7                       
        JNZ     next
        RET
;------------------------------------------------------------------------------
ISR_TIMER_A0:

        INC     R7                      ; Increase the counter

        CMP     countsNeeded(R6), R7   
        JNE     end_timer_interrupt     ; Ignore the current interrupt
        
        ; We reached the needed cycles
        CALL    #SUB_timerAction        ; name pending
        MOV     #0, R7                  ; Reset R7
        
      
end_timer_interrupt: 
        BIC.w     #LPM0, 0(SP)             ; Exit Low Power mode 0
        RETI

;------------------------------------------------------------------------------

;------------------------------------------------------------------------------

 ;Interrupt Service Routine (ISR) that is executed when button S1
 ;is pressed.

;------------------------------------------------------------------------------

; Author(s): Jann C. Garcia
; Date: November 12, 2022
; Description: TODO
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None

ISR_PORT1:   

        NOP                            
	bic.b   #00000110b, &P1IFG	  ;Reset interrupt flag
        NOP  

        PUSH.w  R10                     ; Store original value of R10
        MOV.b   &P1IN, R10               ; Get button state from P1
        AND.b   #00000110B, R10         ; Apply bit mask to value

        CMP.b    S1, R10                 ; Check if S1 was pressed (sets to 0 when pressed)
        JEQ     callButton1Action
        
        
        CMP.b    S2, R10                  ; Check if S2 was pressed 
        JEQ     callButton2Action
        JMP     end_ISR_Port1
        
callButton1Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R10               ; Get button state from P1 
        AND.b   #00000110B, R10          ; Apply bit mask to value

        CMP.b   S1, R10
        JEQ     end_ISR_Port1

        CALL    #SUB_S1Action
        JMP     end_ISR_Port1           ; Skip over button2 action
        
callButton2Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R10               ; Get button state from P1 
        AND.b   #00000110B, R10          ; Apply bit mask to value

        CMP.b   S2, R10
        JEQ     end_ISR_Port1
        
        CALL    #SUB_S2Action


end_ISR_Port1
        POP.w   R10                     ; Restore original value of R10
        BIC.w   #LPM0, 0(SP)           ; Exit Low Power mode 0
	reti
;------------------------------------------------------------------------------
        
END