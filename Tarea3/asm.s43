#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    ISR_TIMER_A0            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    ISR_PORT1               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM 

;       00 AF DD D3 D6 F0 3A --> 10, 0, 18, 8, 13, 14 name proScore testScore
;       
;
;

;------------------------------------------------------------------------------
;Letters and Symbols
;            A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z   NONE    -     >     ?    30    31    32    33    34    35    36    37    38    39
;            0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25   26    27    28    29    0     1     2     3     4     5     6     7     8     9   
CharH   db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x00, 0x78, 0x0E, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0x03, 0x00, 0xC5, 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7


CharL   db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x22, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x00, 0x88, 0x10, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00

;------------------------------------------------------------------------------
; Display Strings
; Array of CharH and CharL INDICES

; Players
jann            DB      9, 0, 13, 13, 26, 26
isabel          DB      8, 18, 0, 1, 4, 11
vandie          DB      21, 0, 13, 3, 8, 4
ricard          DB      17, 8, 2, 0, 17, 3
dracir          DB      3, 17, 0, 2, 8, 17
uimerf          DB      20, 8, 12, 4, 17, 5
oravan          DB      14, 17, 0, 21, 0, 13
noName          DB      27, 27, 27, 27, 27, 27


; Misc. Titles
kasino          DB      10, 0, 18, 8, 13, 14
record          DB      17, 4, 2, 14, 17, 3
test            DB      19, 4, 18, 19, 26, 26    
pro             DB      15, 17, 14, 26, 26, 26
player          DB      15, 11, 0, 24, 4, 17
mode            DB      12, 14, 3, 4, 26, 19    ; NOTE: To make Y/N appear after mode
                                                ; edit @mode+5 (the final position)

;                       T   P
modeValues      DB      19, 15

s2clr           DB      18, 32, 2, 11, 17, 26
perdio          DB      15, 4, 17, 3, 8, 14
gano            DB      6, 0, 13, 14, 26, 26

; Array of string addresses
;                       0       2       4           6     8        10    12       14
recordPage      DW      record, noName, highScore, test, testScore                                 ; Indexed by R8 * 2
                               ; ^ 
                               ; |
                               ; Change value to namePage[nameIndex]; default: noName
namePage        DW      player, ricard, jann, isabel, vandie, dracir, uimerf, oravan, noName            ; Indexed by R5 * 2
resultPage      DW      perdio, gano                                                            ; Indexed by R9 * 2



;                       0       2           4         6     10      12          14
pages           DW      kasino, recordPage, namePage, mode, number, resultPage, s2clr   ; Indexed by R4 * 2

; LCD Offsets
LCD_offsets db 9, 5, 3, 18, 14, 7

; Input Buttons
S1              db      00000100B 
S2              db      00000010B

; Timer Mode Counts (seconds)
;                       1/8   1/4   1/2  1   2   5
countsNeeded    DB      1,    2,    4,   8, 16, 40

; Game timer modes      2  2  1  1/2  1/4  1/8
proTimerModes   DB      4, 4, 3, 2,   1,   0

; Game number (0 = 30 ... 9 = 39)
number          DB      30, 30, 30, 30, 30, 30

highScore       DB      26, 26, 26, 26, 26, 30           ; Change highScore+5 w/ FRAM value
testScore       DB      26, 26, 26, 26, 26, 30           ; Change testScore+5 w/ FRAM value


;------------------------------------------------------------------------------
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

        ; === Port Settings ===

        ; Port 1 Setup
        bis.b   #011111001B, &P1DIR     ; Port 1.1 & Port 1.2 for button input, all other as output
        bis.b   #00000001b, &P1OUT      // Turn on red LED. On if timer is on, off otherwise

	bis.b   #00000110B, &P1OUT	; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1

        bis.b   #00000110B, &P1IES     ; Int generated on high to low transition
        bis.b   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2


        ; Port 9 Setup
        bis.b 	#10000000b, &P9OUT       // Turn on green LED. Toggles every timer action
	bis.b   #011111111B, &P9DIR     // All Port 9 pins as output


        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        ; === LCD Settings ===

        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
          
        ; Initialize LCD 
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0            ; turn the LCD on


        ; === Timer Settings ===

        BIC     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.125 seg
        ; cycles = 15625.  With period = 0.125 LED turn on every 1 second

        mov     #15625, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.



main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer  

        CALL    #reset                  ; Reset values
                         
        nop				; required before enabling interrupts

        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers

        nop                             ; Required after enabling interrupts
          
          
        ; At this point, the MSP430 is now in low power mode
        ; and can only handle interrupts.
        ; Because of this, all code should be handled using interrupts
        


;------------------------------------------------------------------------------
SUB_updateCurrentPage:
        
        PUSH.w  R10                     ; Preserve the original value of R10
                                        ; R10 will contain the page that we want to render

        PUSH.w  R11                     ; Preserve the original value of R11
                                        ; R11 will contain the amount we need to shift R10 by


        PUSH.w  R4                      ; Preserve the original value of R4
                                        ; R4 will be multiplied by 2 to index "pages"

        RLA     R4                      ; Multiply R4 by 2

        MOV.w   pages(R4), R10          ; At this point, R10 is either an address pointing to a string
                                        ; or an address pointing to array of string pointers

        POP.w   R4                      ; Restore R4's value

        CMP     #1, R4                  ; Record (indexes R10 using R8)
        JEQ     shiftR10ByR8
        
        CMP     #2, R4                  ; Names (indexes R10 using R5)
        JEQ     shiftR10ByR5
        
        CMP     #5, R4                  ; Result (indexes R10 using R9)
        JEQ     shiftR10ByR9
        
        JMP     endDisplay              ; It's an address that points to a string!
        
shiftR10ByR8:
        MOV     R8, R11
        JMP     shiftLoop
        
shiftR10ByR5:
        MOV     R5, R11
        JMP     shiftLoop
        
shiftR10ByR9:
        MOV     R9, R11

shiftLoop:
        CMP     #0, R11
        JEQ     endLoop
        
        
        INCD    R10                     ; Increase R10 by 2 (since addresses are words)
                                        ; R10 now points to the next address in the array
        DEC     R11
        JMP     shiftLoop
        
endLoop:
        MOV     @R10, R10               ; Turn R10 from an address that points to an address that points to a string
                                        ; to an address that points to a string

endDisplay:
      
        CALL    #SUB_displayStringOnLCD
        POP.w   R11                    ; Restore R11's value
        POP.w   R10                    ; Restore R10's value
        RET
        
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Author: Jann C. Garcia
; Date: November 12, 2022
; Description:
; * Receives a starting address from R10, and displays the next 6 characters
; * on the LCD. 

; Pre-Conditions: 
; * R10 must denote a location of memory where a string commences
; * The string MUST be of bytes. Words will not work

; Post-Conditions: None
; Side Effects: None

SUB_displayStringOnLCD:
        ; Setup
        PUSH.w R10                      ; R10: Starting address in RAM of string
                                        ; Each position is an index for CharH/CharL
                                        ; Move 6 places and display each digit

        PUSH.w R11                      ; R11: Goes from 0-6
                                        ; Due to LCD addresses NOT being in order,
                                        ; we need to use LCD_offsets, which contains
                                        ; the correct offset for each segment of the LCD
                                        ; For example: segment 0 is 0xA29 (A20 + 9 offset)
                                        ; but segment 1 is 0xA25 (A20 + 5 offset)

        PUSH.w R12                      ; R12: The index of CharH/CharL
        
        MOV     #0, R11
        
displayLoop:

        MOV.b   @R10+, R12              ; Store the value AT (@) R10 into R12
                                        ; The + increments the value IN R10
                                        ; so that R10 will point to the next byte
                                        ; in RAM

        PUSH.W  R11                     ; Temporarily store R11's index
        
        MOV.b   LCD_offsets(R11), R11   ; Grab the current offset for R11
        MOV.b   CharH(R12), 0x0A20(R11)   ; High Byte
        MOV.b   CharL(R12), 0x0A20+1(R11) ; Low Byte
        
        POP.w   R11                     ; Restore R11's index
        INC.b   R11                     ; and increase it by 1
        
        CMP     #6, R11                 ; End if R11 has reached 6
        JL      displayLoop
        
        ; Restore original values to prevent side effects
        POP.w   R12
        POP.w   R11
        POP.w   R10
        
        RET

;------------------------------------------------------------------------------
SUB_validateFRAM:
        PUSH.w  R10                     ; Preserve R10's value
                                        ; R10 will be the relative index for FRAM
                                        ; @ 0x4400

        MOV.b   #0, R10                 ; Start at index 0
        
        
validationLoop:
        ; Check 0x4400 -> 0x4405 for "KASINO" or whatever value we put for validation
        ; If it matches, load from FRAM
        
        CMP.b   kasino(R10), 0x4400(R10)        ; Compare kasino[R10] to FRAM[R10]

        ; If at any point we don't match, we need to reset FRAM
        JNE     resetFRAM

        INC.b   R10

        CMP.b   #6, R10
        JL      validationLoop
        JMP     loadFRAM                        ; If we make it here
                                                ; that means the validation string
                                                ; was inside the FRAM
        
resetFRAM:
        CALL    #SUB_resetFRAM
        
loadFRAM:
        CALL    #SUB_loadFromFRAM
        


        POP.w   R10                     ; Restore R10's value
        RET
        
SUB_loadFromFRAM:
        ; 0x4400 -> 0x4405: Validation String
        ; 0x4406: Name Index
        ; 0x4407: Pro Score
        ; 0x4408: Test Score


        ; Loading Name
        PUSH.w  R10                     ; R10: FRAM index + 6
        PUSH.w  R11                     ; R11: Address of page to edit
        PUSH.w  R12                     ; R12: FRAM value @ 0x4406

        MOV.b   #6, R10 
        MOV.w   #recordPage, R11    
        MOV.b   0x4400(R10), R12        ; R12 now contains the VALUE at 0x4406

        RLA     R12                     ; Multiply R12 by 2
        
        
        MOV.w   namePage(R12), 2(R11)
        
        ; Loading Scores
        INC.b   R10                     ; R10 now points to 0x4407
        MOV.w   #testScore, R11
        MOV.b   0x4400(R10), 5(R11)     ; Loading Test Score

       
        INC.b   R10                     ; R10 points to 0x4408
        MOV.w   #highScore, R11
        MOV.b   0x4400(R10), 5(R11)     ; Loading Pro Score
        
        
        ; Load namePage[2 * value @ 0x4406] into recordPage[2 * 1]
        ; Load value @ 0x4407 into highScore[5]
        
        POP.w   R12
        POP.w   R11
        POP.w   R10
        RET

SUB_resetFRAM: ; Will be called ONLY on first program run AND S2CLR
        ; 0x4400 -> 0x4405: Validation String
        ; 0x4406: Name Index
        ; 0x4407: Test Score
        ; 0x4408: Pro Score

        PUSH.w  R10

        MOV.b   #0, R10                 ; R10 = FRAM Index

       

stringLoop:
        ; Set the validation string
        MOV.b   kasino(R10), 0x4400(R10)
        INC.b   R10
        CMP.b   #6, R10
        JL      stringLoop
        
        ; R10 == 6
        MOV.b   #8, 0x4400(R10)         ; This will reset the name INDEX to "noName"

        INC.b   R10
        
        ; R10 == 7
        MOV.b   #30, 0x4400(R10)         ; Reset Test Score to 30 (0 in char array)
        INC.b   R10
    
        ; R10 == 8
        MOV.b   #30, 0x4400(R10)        ; Reset Pro Score to 30
        


        POP.w  R10
        RET
        
SUB_saveToFRAM:

        
        ; R5 = Player Index
        ; R10 = Score (not 30-based)
        ; R11 = Game Mode

        PUSH.w  R5
        PUSH.w  R12                     ; The score to compare to (testScore[5] if R11 == 0, highScore[5] if R11 == 1)

        CMP.b   #0, R11                 ; Check what game mode we are on
        JEQ     loadTestScore
               
        MOV.w   #highScore, R12
        JMP     compare
        
loadTestScore
        MOV.w   #testScore, R12
        
compare:
        ADD.b   #30, R10                 ; Make score 30-based
        CMP.b   5(R12), R10
        JL      endSave
        
        ; Update the score
        MOV.b   R10, 0x4407(R11)         ; Save 30-based R10 into FRAM
                                        ; using the game mode as an index

        CMP.b   #1, R11
        JEQ     saveName                ; Save name only in pro mode
        JMP     endSave
        
saveName:
        MOV.w   #0x4406, R12
        MOV.b   R5, 0(R12)              ; Move name into 0x4406

endSave:
        POP.w   R12
        POP.w   R5
        RET
        

        ; Comparisons to make before saving:
        ; * If gamemode == "pro"
        ;       * If proScore[5] < score + 30
        ;               * Save score to FRAM (0x4407)
        ;               * Save R5 to FRAM (0x4406)

        ; * Else:
        ;       * If testScore[5] < score + 30
        ;               * Save score to FRAM (0x4408)
        ;               * Save R5 to FRAM (0x4406)


        
;------------------------------------------------------------------------------
SUB_S1Action:
        ; TODO: Set timer mode for state transitions
        CMP     #0, R4
        JEQ     moveToIntroLoop
        
        CMP     #2, R4
        JEQ     moveToNextPlayer
        
        
        CMP     #3, R4
        JEQ     toggleMode
        
        CMP     #4, R4
        JEQ     handleGameState
        
        CMP     #6, R4
        JEQ     resetGame
        
        ;DONE
        
        JMP     end_S1Action
        
;------------------------------------------------------------------------------

moveToIntroLoop:
        MOV     #1, R4                  ; Move to Intro State

        MOV     #4, R6                  ; Set timer to 2 second mode
        CALL    #SUB_enableTimer        ; Reset and enable timer


        JMP     end_S1Action
;------------------------------------------------------------------------------        
moveToNextPlayer:
        INC     R5                      ; Increase name index
        CMP     #8, R5
        JNE     end_S1Action
        
        MOV     #1, R5                  ; Reset Name Index
        JMP     end_S1Action
        
        
        
;------------------------------------------------------------------------------
       
toggleMode:
        XOR     #1, R11
        PUSH.w  R10
        MOV.w   #mode, R10
        
        MOV.b     modeValues(R11), 5(R10)  ; Change mode to T or P
        POP.w   R10
        JMP     end_S1Action
        
;------------------------------------------------------------------------------        
handleGameState:
        PUSH.w  R11
        MOV.w   #number, R11
        CMP.b     number(R10), 0(R11)     ; Compare current number to first number
        POP.w   R11
        JNE     failGame                ; We chose a different number! D:
        
        INC     R10                     ; Increase index to the next number
        
        CMP     #6, R10                 
        JEQ     winGame                 ; We reached the end! :)

        CMP     #1, R11                 ; Check if we are playing pro mode
        JEQ     updateTimerValueForPro
        
        MOV     #4, R6                  ; Set timer to 2 second mode
        JMP     continueGame

updateTimerValueForPro:
        MOV.b     proTimerModes(R10), R6  ; Set timer to mode @ index R10


continueGame:        
        CALL    #SUB_resetTimer         ; Reset the timer
        JMP     end_S1Action            ; We haven't finished yet!
        
failGame:
        MOV     #0, R9                  ; We lost :(
        JMP     moveToResultState
        
winGame:
        MOV     #1, R9                  ; We won!
        
moveToResultState:
        MOV     #5, R4                  ; Move to result state
        MOV     #5, R6                  ;change freq to 5s
        CALL    #SUB_saveToFRAM         ; Save Score
        CALL    #SUB_enableTimer       ; Reset and disable the timer
        JMP     end_S1Action
        
;------------------------------------------------------------------------------
    
resetGame:
        CALL    #reset
        ; TODO: Store High score in FRAM?
        

end_S1Action:        
        RET
      
;------------------------------------------------------------------------------

moveToPlayerSelection:
        CALL    #SUB_disableTimer       ; Disable timer
        MOV     #2, R4                  ; Move to Player Selection State
        JMP     end_S2Action            

moveToGameSelection:   
        CMP     #0, R5
        JEQ     end_S2Action            ; Ignore "Player" as an option
        MOV     #3, R4                  ; Move to Mode Selection State
        JMP     end_S2Action

moveToGameState:                        
        CALL    #SUB_enableTimer        ; Enable timer
        MOV     #4, R6                  ; Set timer to 2 second delay
        MOV     #4, R4                  ; Move to Game
        JMP     end_S2Action

clearFRAM:
        CALL    #SUB_resetFRAM
        JMP     end_S2Action
     
SUB_S2Action:
        CMP     #1, R4
        JEQ    moveToPlayerSelection
        CMP     #2, R4
        JEQ    moveToGameSelection
        CMP     #3, R4
        JEQ    moveToGameState
        CMP     #6, R4
        JEQ    clearFRAM
               
end_S2Action:
        RET      
        
;-------------------------------------TIMER ACTIONS-----------------------------------------

SUB_timerAction:

        CMP     #1, R4                          ;checks if page is 1 
        JEQ     name_Records
        
        CMP     #4, R4
        JEQ     game_State
        
        CMP     #5, R4
        JEQ     result_State 
        
        
end_TimerAction:
        CALL      #SUB_updateCurrentPage       ; Update the page AFTER we performed our action
        XOR.b     #BIT7, &P9OUT         ; Toggle the Green LED
        RET
        
name_Records:
        INC     R8                      ; Increase Record Index (R8)
        CMP     #5, R8                  ; Reset to 0 if it reached 5
        JEQ     reset_Eight
        JMP     end_TimerAction
        
reset_Eight:
        MOV     #0, R8
        JMP     end_TimerAction
        
game_State:
        INC.b     number(R10)           ; Increase number @ R10
        CMP.b     #40,  number(R10)     ; Check if number[R10] reached 10
        JGE     failState                       
        JMP     end_TimerAction

failState:
        MOV     #0, R9                  ; Game Result: Lose 
        MOV     #5, R6                  ; Set timer to 5 second delay
        MOV     #5, R4                  ; Move to result screen
        CALL    #SUB_saveToFRAM         ; Save Score
        JMP     end_TimerAction

result_State:
        MOV     #6, R4                  ; Move to S2CLR
        CALL    #SUB_disableTimer       ; Disable timer
        JMP     end_TimerAction
       
        
;-------------------------------------------------------------------------------
reset:
        MOV     #0, R4                  ; R4 = Current State
                                        ; * 0 = Title State
                                        ; * 1 = Record Loop
                                        ; * 2 = Player Selection
                                        ; * 3 = Mode Selection
                                        ; * 4 = Game State (pro/test defines speed)
                                        ; * 5 = Game result state
                                        ; * 6 = S2CLR State

        MOV     #0, R5                  ; R5 = Name Index
                                        ; * 0 = "Player"
                                        ; * 1 = "Ricard"  <-- loop here!
                                        ; * ...
                                        ; * 7 = "Oravan"
      
        MOV     #0, R6                  ; R6 = Timer Mode
                                        ; * 0 = 1/8th second
                                        ; * 1 = 1/4th second
                                        ; * 2 = 1/2 second
                                        ; * 3 = 1 second
                                        ; * 4 = 2 seconds
                                        ; * 5 = 5 seconds

        MOV     #0, R7                  ; R7 = 1/8th of a second counter (counter)[it counts]

        MOV     #0, R8                  ; R8 = Record Page Index
                                        ; * 0 = "Record"        <-- loop here!
                                        ; * 1 = Record Holder Name
                                        ; * 2 = Record Holder Score
                                        ; * 3 = "Test"
                                        ; * 4 = Test Record Score

        MOV     #0, R9                  ; R9 = Game Result
                                        ; * 0 = Lose :(
                                        ; * 1 = Win  :)

        MOV     #0, R10                 ; R10 = Current Game Number
                                        ; * 0 = First Number
                                        ; * ...
                                        ; * 5 = Last Number
  
        MOV     #0, R11                 ; R11 = Game Mode
                                        ; * 0 = Test
                                        ; * 1 = Pro

        MOV     #0, R12                 ; R12 = Button State

        CALL    #SUB_validateFRAM       ; Validate & Reset if needed

        CALL    #SUB_disableTimer       ; Reset and Disable the timer

resetGameDigits:
        PUSH.w    R13                   ; Preserve R13
        MOV.b     #0, R13
        
resetLoopDigits:
        MOV.b     #30, number(R13)      ; Reset all values to 0
        INC.b     R13
        CMP.b     #6, R13               ; Loop 6 times
        JL      resetLoopDigits
        
resetModeValue:
        MOV.w   #mode, R13              ; Move address into R3
        MOV.b   #19, 5(R13)             ; Set the last char to "T"
        POP.w   R13                     ; Restore R13
        
        RET

;------------------------------------------------------------------------------
SUB_resetTimer:
        MOV     #0, R7                  ; Reset Counter
        RET

SUB_disableTimer:
        CALL    #SUB_resetTimer         ; Reset Timer
        BIC     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer

        BIC.b   #BIT0, &P1OUT      // Turn off red LED
        RET
        
SUB_enableTimer:
        CALL    #SUB_resetTimer         ; Reset Timer
        BIS     #CCIE, &TA0CCTL0        ; Disable TACCR0 interrupt
                                        ; This turns off the timer

        BIS.b   #BIT0, &P1OUT      // Turn on red LED


        RET


;------------------------------------------------------------------------------

; Author: Jann C. Garcia
; Date: October 31, 2022
; Description: Delays the program 9for debouncing)
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None


delay:  ; Used to delay the program
        ; giving the MSP time to handle
        ; button pressed (debouncing)

        PUSH.w    R7                            ; Preserve Original Value                       
        CALL    #delayStart
        POP.w     R7                              ; Restore Original Value
        RET
        
delayStart:
        MOV     #0xFFFF,R7                      ; Set R7 to an abnormally high value       


next:   ; Decrease R7 all the way to 0
        DEC     R7                       
        JNZ     next
        RET
;------------------------------------------------------------------------------
ISR_TIMER_A0:

        INC     R7                      ; Increase the counter
        PUSH.w    R12

        MOV.b   countsNeeded(R6), R12
        CMP.b   R12, R7   
        POP.w     R12
        JNE     end_timer_interrupt     ; Ignore the current interrupt

        
        ; We reached the needed cycles
        CALL    #SUB_timerAction        ; name pending
        MOV     #0, R7                  ; Reset R7
        
      
end_timer_interrupt: 
        RETI

;------------------------------------------------------------------------------

;------------------------------------------------------------------------------

 ;Interrupt Service Routine (ISR) that is executed when button S1
 ;is pressed.

;------------------------------------------------------------------------------

; Author(s): Jann C. Garcia
; Date: November 12, 2022
; Description: TODO
; Pre-Conditions: None
; Post-Conditions: None
; Side Effects: None

ISR_PORT1:   
        
        NOP                            
	bic.b   #00000110b, &P1IFG	  ;Reset interrupt flag
        NOP  
        
        MOV.b   &P1IN, R12               ; Get button state from P1
        AND.b   #00000110B, R12         ; Apply bit mask to value

        CMP.b    S1, R12                 ; Check if S1 was pressed (sets to 0 when pressed)
        JEQ     callButton1Action
        
        
        CMP.b    S2, R12                  ; Check if S2 was pressed 
        JEQ     callButton2Action
        JMP     end_ISR_Port1
        
callButton1Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R12               ; Get button state from P1 
        AND.b   #00000110B, R12          ; Apply bit mask to value

        CMP.b   S1, R12
        JEQ     end_ISR_Port1

        CALL    #SUB_S1Action
        JMP     end_ISR_Port1           ; Skip over button2 action
        
callButton2Action:
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R12               ; Get button state from P1 
        AND.b   #00000110B, R12          ; Apply bit mask to value

        CMP.b   S2, R12
        JEQ     end_ISR_Port1
        
        CALL    #SUB_S2Action


end_ISR_Port1
        CALL    #SUB_updateCurrentPage       ; Update the page AFTER we performed our action
	reti
;------------------------------------------------------------------------------
   
endProgram:                             ; Theoretically should never run
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)    
        END